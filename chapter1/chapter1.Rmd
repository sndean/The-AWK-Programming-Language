---
title: "chapter1"
author: "snd"
date: "6/19/2018"
output: pdf_document
---



# AWK






## 1.1 Getting started

Here's a list of employees, pay rate, and hours worked

```{bash}
cat emp.data
```


Calculating pay for people who worked > 0 hours

```{bash}
mawk '$3 > 0 {print $1, $2*$3}' emp.data
```

The people who didn't work

```{bash}
mawk '$3 == 0 {print $1}' emp.data
```


As you may be able to see from the above two examples, most of the awk programs we'll be writing have a certain set up: `pattern {action}`, where we have a pattern that we match (e.g., the 3rd field is `0`) and then an action based on those rows that match the pattern.












## 1.2 Simple output

In the first code chunk, I wrote `cat emp.data`. The awk equivalent is

```{bash}
mawk '{print}' emp.data
```

`print $0` will also print the whole line


```{bash}
mawk '{print $0}' emp.data
```

Now without the pay rate

```{bash}
mawk '{print $1, $3}' emp.data
```

Note that comma between field 1 and 3 is semirequired. See the output without the comma.

```{bash}
mawk '{print NF, $1, $NF}' emp.data
```

`NF` can be used here as an alternative to `$3`, where awk counts the number of fields for every line, which yields a 3 to start every column. 

Another built in variable is `NR`

```{bash}
mawk '{print NR, $1}' emp.data
```

This, paired with `$1` outputs the line number with every name. You can also adjust the output by adding text

```{bash}
mawk '{print "The total pay for", $1, "is", $2 * $3}' emp.data
```









## 1.3 Fanicer output

This printing can be made fanicer by using `printf`

```{bash}
mawk '{printf "The total pay for %-5s is $%6.2f \n", $1, $2 * $3}' emp.data
```

If you have any experience with C's `printf` (and many other similar `printf`s), you can do the same here with awk. Adjust the justification, number of digits before and after the decimal, etc.



Awk doesn't need to be used in isolation. If you want to use `sort` pipe it to `sort`

```{bash}
mawk '{printf "$%6.2f %s\n", $2 * $3, $1}' emp.data | sort
```








## 1.4 Selection


The people that worked 20 or more hours

```{bash}
mawk '$3 >= 20' emp.data 
```

The people that were paid more than $50

```{bash}
mawk '$2 * $3 > 50 {printf "%s made more than $50: $%-6.2f\n", $1, $2 * $3}' emp.data 
```


You can do more than just select based on numbers. Here's characters

```{bash}
mawk '$1 == "Mark"' emp.data 
```

and using regular expressions

```{bash}
mawk '/Ma/' emp.data
```

`||` is *or* `&&` is *and*

```{bash}
mawk '/Ma/ || /th/' emp.data
```

```{bash}
mawk '/Ma/ && $3 > 21' emp.data
```

You can also use these for data validation. E.g., you can't be paid negative dollars, work negative hours, or have more fields than 3 (in this case). Here's that implemented in awk

```{bash}
mawk 'NF != 3 || $2 < 0 || $3 < 0' emp.data
```

Since there's no errors, there's no output. To make sure this is the case. I'll make `emp_error.data`.

```{bash}
mawk 'NF != 3 || $2 < 0 || $3 < 0' emp_error.data
```


In addition to `NF` and `NR`, there's `BEGIN` and `END`

```{bash}
mawk 'BEGIN {print "NAME RATE HOURS"}{print}' emp.data
```








## 1.5 Computing with awk

Here's how to count the number of people who worked. Remember it should be 4.

```{bash}
mawk '$3 > 0' emp.data
```

```{bash}
mawk '$3 > 0 {emp += 1} END {print emp}' emp.data
```

Or, what fraction of the total employees worked more than 0 hours?

```{bash}
mawk '$3 > 0 {emp += 1} END {print emp / NR}' emp.data
```

Using these ideas, you can easily print the total amount paid out to the people in `emp.data`, the average pay, and the total and average number of hours worked.

```{bash}
mawk '{pay = pay + $2 * $3; hours = hours + $3} END {
printf "the total pay is %.2f\n\
the average pay is %.2f\n\
the total number of hours is %.2f\n\
the average number of hours is %.2f\n",
pay, pay/NR, hours, hours/NR}' emp.data
```


















